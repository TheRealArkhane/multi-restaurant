package com.testcase.commondto.waiterservice;

import java.util.Set;

/**
 * Статусы заказа на кухне, отражающие его жизненный цикл.
 */
public enum OrderStatus {

    /**
     * Статус, означающий, что заказ собирается для отправки на кухню.
     * Используется, когда официант набирает позиции, заказанные на столе.
     * Не фигурирует в БД kitchen-service
     */
    PREPARING,

    /**
     * Статус, означающий, что заказ был отменён до отправки в кухню.
     * Используется, когда заказ был отменён официантом до того, как он был отправлен на кухню,
     * следовательно, не был создан в БД kitchen-service.
     */
    CANCELLED_BEFORE_SEND,

    /**
     * Статус, означающий, что заказ отправлен на кухню.
     * Используется, когда заказ был принят кухней (записан в БД kitchen-service) и ожидает обработки.
     */
    SENT_TO_KITCHEN,

    /**
     * Статус, означающий, что заказ был отменён официантом после отправки на кухню.
     * Используется, когда официант решает отменить заказ после его отправки
     * на кухню до того, как кухня начала его готовку.
     * Количество блюд, зарезервированное на заказ, возвращается на баланс блюд в БД.
     * (например, посетитель вдруг передумал брать какое-то блюдо).
     */
    CANCELLED_BY_WAITER,

    /**
     * Статус, означающий, что заказ был отменён кухней до того, как возьмет его в работу
     * Используется, если кухня отменяет заказ по каким-либо причинам.
     * Количество блюд, зарезервированное на заказ, возвращается на баланс блюд в БД.
     * (например, поломка аппаратуры, отключение света или иные внештатные ситуации).
     */
    CANCELLED_BY_KITCHEN,

    /**
     * Статус, означающий, что заказ в процессе готовки.
     * Используется, когда кухня начала готовить блюдо.
     */
    COOKING,

    /**
     * Статус, означающий, что заказ был отменён во время готовки официантом.
     * Используется, если официант решает отменить заказ во время его готовки на кухне.
     * Количество блюд, зарезервированное на заказ, уже не возвращается на баланс блюд в БД.
     * (например, отключение света, проблемный клиент или иные внештатные ситуации).
     */
    CANCELLED_WHILE_COOKING_BY_WAITER,

    /**
     * Статус, означающий, что заказ был отменён кухней во время готовки.
     * Используется, если кухня решает отменить заказ во время его готовки на кухне.
     * Количество блюд, зарезервированное на заказ, уже не возвращается на баланс блюд в БД.
     * (например, отключение света, поломка аппаратуры или иные внештатные ситуации).
     */
    CANCELLED_WHILE_COOKING_BY_KITCHEN,

    /**
     * Статус, означающий, что заказ готов.
     * Используется, когда блюдо готово и ожидает оплаты и сервировки.
     * Это конечный позитивный статус для заказов в БД кухни. Дальнейшие статусы являются
     * внутренними для БД waiter-service
     */
    READY,

    /**
     * Статус, означающий, что заказ не был успешно завершён по причине, связанной с официантом.
     * Используется, если заказ не был выполнен из-за ошибки со стороны официанта.
     * (например, официант нес заказ и уронил его).
     * Является внутренним статусом для БД waiter-service и не идет в БД кухни.
     */
    UNSUCCESSFUL_WAITER_REASON,

    /**
     * Статус, означающий, что заказ не был успешным из-за неоплаченного счёта.
     * Используется, если заказ был отменён из-за того, что клиент не оплатил.
     * Не является конечным, т.к. посетитель может повторить оплату.
     * Является конечным, только если посетитель платит наличными и у него
     * недостаточно денег без возможности дальнейшей оплаты, и присваивается
     * официантом вручную через /orders/{id}/cancel с указанием PaymentType.CASH
     * в API waiter-service.
     * Является внутренним статусом для БД waiter-service и не идет в БД кухни.
     */
    UNSUCCESSFUL_VISITOR_UNPAID,

    /**
     * Статус, означающий, что заказ был оплачен и ожидает сервировки.
     * Используется, когда заказ оплачен, но ещё не подан гостю.
     * Является внутренним статусом для БД waiter-service и не идет в БД кухни.
     */
    PAID_AWAITING_SERVING,

    /**
     * Статус, когда заказ не был успешным по причине, связанной с клиентом.
     * Используется, если заказ был отменён по вине клиента.
     * (например, сбежал после приема пищи или недоволен качеством еды и требует разбирательства).
     * Является внутренним статусом для БД waiter-service и не идет в БД кухни.
     */
    UNSUCCESSFUL_VISITOR_REASON,

    /**
     * Статус, означающий, что заказ был оплачен и подан клиенту.
     * Используется как финальный позитивный статус, завершающий жизненный цикл заказа.
     * Является внутренним статусом для БД waiter-service и не идет в БД кухни.
     */
    PAID_AND_SERVED;

    /**
     * Финальные статусы заказа, после которых дальнейшие изменения невозможны.
     */
    private static final Set<OrderStatus> FINAL_STATUSES = Set.of(
            CANCELLED_BEFORE_SEND,
            CANCELLED_BY_WAITER,
            CANCELLED_BY_KITCHEN,
            CANCELLED_WHILE_COOKING_BY_WAITER,
            CANCELLED_WHILE_COOKING_BY_KITCHEN,
            UNSUCCESSFUL_WAITER_REASON,
            UNSUCCESSFUL_VISITOR_REASON,
            PAID_AND_SERVED);


    /**
     * Разрешенные статусы для отмены заказа.
     */
    public static final Set<OrderStatus> ALLOWED_CANCEL_STATUSES = Set.of(
            OrderStatus.CANCELLED_BEFORE_SEND,
            OrderStatus.CANCELLED_BY_WAITER,
            OrderStatus.CANCELLED_WHILE_COOKING_BY_WAITER,
            OrderStatus.UNSUCCESSFUL_WAITER_REASON,
            OrderStatus.UNSUCCESSFUL_VISITOR_UNPAID,
            OrderStatus.UNSUCCESSFUL_VISITOR_REASON
    );

    /**
     * Проверяет возможность перехода из текущего статуса в новый.
     * <p>
     * Переход допустим, если текущий статус не финальный и ordinal текущего статуса меньше ordinal нового.
     *
     * @param newStatus статус, в который требуется перейти
     * @return {@code true}, если переход возможен, иначе {@code false}
     */
    public boolean canTransitTo(OrderStatus newStatus) {
        if (newStatus == null || FINAL_STATUSES.contains(this)) {
            return false;
        }
        return this.ordinal() < newStatus.ordinal();
    }
}
